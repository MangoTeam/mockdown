from __future__ import annotations

from fractions import Fraction
from typing import TypeVar, Union, SupportsAbs, SupportsFloat, Tuple, SupportsRound, SupportsInt, overload

"""
Some type stubs to make mypy happy when dealing with sympy.
Warning: these may have subtle problems, after all, we wrote them...
"""

N = TypeVar('N', bound='Number')

# Type of anything that is compatible with Number's operators.
_AnyNum = Union['Number', int, float]

# Type of things convertible to a Number.
_ToNum = Union['Number', str, int, float, Fraction]


class Basic: ...


class Atom(Basic): ...


class Expr(Basic): ...


class AtomicExpr(Atom, Expr): ...


class Number(AtomicExpr, SupportsAbs['Number'], SupportsInt, SupportsFloat, SupportsRound):
    def __init__(self, value: _ToNum) -> None: ...

    def __add__(self: N, other: _AnyNum) -> N: ...

    def __sub__(self: N, other: _AnyNum) -> N: ...

    # todo: this is incorrect for int/int -> rat
    def __truediv__(self: N, other: _AnyNum) -> N: ...

    def __abs__(self: N) -> N: ...

    def __round__(self, ndigits: int = 0) -> int: ...

    def __int__(self: N) -> int: ...

    def __float__(self: N) -> float: ...

    def __lt__(self: N, other: _AnyNum) -> bool: ...

    def __le__(self: N, other: _AnyNum) -> bool: ...

    def __gt__(self: N, other: _AnyNum) -> bool: ...

    def __ge__(self: N, other: _AnyNum) -> bool: ...

    def __eq__(self: N, other: object) -> bool: ...


class Float(Number): ...


class Rational(Number):
    @overload
    def __init__(self, x: int): ...

    @overload
    def __init__(self, x: Integer): ...

    @overload
    def __init__(self, p: int, q: int): ...

    @overload
    def __init__(self, p: Integer, q: Integer): ...

    @property
    def p(self) -> Integer: ...

    @property
    def q(self) -> Integer: ...

    def limit_denominator(self, max_denominator: int) -> Rational: ...

    def as_numer_denom(self) -> Tuple[Integer, Integer]: ...



class Integer(Rational): ...

